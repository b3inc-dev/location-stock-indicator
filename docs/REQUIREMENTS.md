# Location Stock Indicator 要件・実装メモ

## 1. データの流れ（サイト経路）

- **管理画面**で保存した内容は、ショップのメタフィールド `location_stock.config`（JSON）に保存される。
- **商品ページ**では、テーマの App Block が **App Proxy**（`/apps/location-stock?variant_id=xxx`）を呼び出す。
- App Proxy はメタフィールドを読み、在庫リスト（`stocks`）とグローバル設定（`config`）を JSON で返す。各 stock には在庫数・表示名に加え、並び順用の `hasShipping` / `hasLocalDelivery` / `storePickupEnabled`、および近隣検索用の `excludeFromNearby` を付与する（`deliveryProfiles` と `Location.localPickupSettingsV2`、`config.locations` から取得）。
- テーマ拡張の **スニペット**（`location-stock-indicator.liquid`）が `config` と `stocks` を受け取り、表示・絞り込み・並び順を適用する。

---

## 2. 実装済み機能と経路の対応

### 2.1 閾値（在庫なし／残りわずか／在庫ありの境界）

| 項目 | 内容 |
|------|------|
| 設定場所 | **在庫表示設定**（一番上） |
| 保存 | `config.thresholds.outOfStockMax` / `config.thresholds.inStockMin` |
| App Proxy | `buildGlobalConfig` で `config.thresholds` を返す |
| サイト | スニペットが `appConfig.thresholds` で `settings.outOfStockMax` / `settings.inStockMin` を更新し、`getStatusSymbolAndLabel` で在庫あり／残りわずか／在庫なしを判定 |

**経路**: 在庫表示設定 → メタフィールド → App Proxy → config → スニペット ✅

---

### 2.2 ロケーション表示ルール

| 項目 | 内容 |
|------|------|
| 設定場所 | **ロケーション設定**（ロケーション一覧の「表示」チェックと「公開名」） |
| 保存 | `config.locations` 配列（各要素: `locationId`, `enabled`, `publicName`, `sortOrder`, `regionGroupId`, `excludeFromNearby`） |
| 表示ルール | 「チェックが入っているロケーションだけ表示」「公開名があれば公開名、なければロケーション名」 |
| App Proxy | `applyConfigToStocks` で `displayName`（公開名 or ロケーション名）、`fromConfig`、`enabled` を付与。`config.locations.mode` は `buildGlobalConfig` で `config.locations` に含めて返す |
| サイト | スニペットの `filterLocations` で `locationsMode` に応じて絞り込み。`custom_from_app` のときは `fromConfig === true` のみ表示 |

**経路**: ロケーション設定 → メタフィールド → App Proxy（stocks + config.locations） → スニペット ✅

---

### 2.3 並び順・上部固定

| 項目 | 内容 |
|------|------|
| 設定場所 | **ロケーション設定**（並び順セクション ＋ ロケーション一覧の「上部固定」列で 1 件だけラジオ選択） |
| 保存 | `config.sort.mode`（none / location_name_asc / quantity_desc / quantity_asc / in_stock_first / store_pickup_first / shipping_first / local_delivery_first）、`config.pinnedLocationId` |
| App Proxy | `buildGlobalConfig` で `config.sort` と `config.pinnedLocationId` を返す |
| サイト | スニペットが `settings.sortBy` と `settings.pinnedLocationId` を更新。`sortLocations` で上部固定ロケーションを先頭にし、残りを `sortBy` でソート |

**経路**: ロケーション設定 → メタフィールド → App Proxy → config → スニペット ✅

**補足（実装済み）**: App Proxy で各 stock に `hasShipping` / `hasLocalDelivery` / `storePickupEnabled` を付与（`deliveryProfiles` と `Location.localPickupSettingsV2` から取得）。スニペットの `sortLocations` で `location_name_asc` / `quantity_desc` / `quantity_asc` / **上部固定** に加え、`in_stock_first` / `store_pickup_first` / `shipping_first` / `local_delivery_first` の 4 種のソート分岐を実装済み。

---

### 2.4 近隣店舗表示からの除外

| 項目 | 内容 |
|------|------|
| 設定場所 | **ロケーション設定**（ロケーション一覧の「近隣除外」列、表示の右） |
| 保存 | `config.locations[].excludeFromNearby`（boolean） |
| App Proxy | `applyConfigToStocks` で各 stock に `excludeFromNearby` を付与 |
| サイト | スニペットの近隣店舗アコーディオンで、`excludeFromNearby === true` のロケーションを近隣検索・表示対象から除外 |

**経路**: ロケーション設定 → メタフィールド → App Proxy（stocks） → スニペット ✅

---

### 2.5 在庫表示設定のその他

- **在庫マーク**（◯△✕）、**在庫数ラベル・前後の文字**、**ステータスラベル**、**メッセージ文言**、**注意書き**、**クリック設定**  
  → いずれもメタフィールド → `buildGlobalConfig` → スニペットで `appConfig` から `settings` に反映。  
- **並び順**はロケーション設定に集約してあり、在庫表示設定には並び順の項目はない。

---

## 3. 管理画面の構成

- **ホーム**（`app._index.jsx`）  
  「このアプリについて」、**1. ロケーション設定**（StepCard）、**「配送対応」「ローカルデリバリー対応」について**（案内カード：配送プロファイルの説明と「配送設定を開く」ボタン・別タブで Shopify の配送設定を開く）、**2. 在庫表示設定**（StepCard）。
- **在庫表示設定**（`app.settings.jsx`）  
  閾値（一番上）、在庫マーク、在庫数テキスト、ステータスラベル、メッセージ、注意書き、クリック設定のみ。並び順はなし。
- **ロケーション設定**（`app.locations.jsx`）  
  **並び順**（セレクト）、**エリア設定**（エリアでグルーピング・エリアごとに折りたたみ・未設定の見出し（デフォルト「その他」）・グループ一覧と並び順・エリアを追加）、**近隣店舗表示設定**（近隣店舗を表示チェック、その他ロケーションの見出し入力）、**店舗受取設定**（「この店舗で受け取る」ボタン表示・ボタンラベル・ボタンタップ後にチェックアウトまでリダイレクトするチェック）、**ロケーション一覧**テーブル（ロケーション名・公開名・エリア・並び順・上部固定・表示・近隣除外）。配送対応／ローカルデリバリー対応／店舗受け取り対応は API から行ごとに表示。エリア見出し・ボタンの**デザイン**は管理画面にはなく、テーマのカスタマイザー（ブロックスキーマ）で設定する。スマホ時はテーブル横スクロール可能。

---

## 4. エラーログ

- App Proxy 内で `logAppProxyError(shop, variantId, code, message, err)` を呼び出し、エラー時にショップ・variant_id・コード・メッセージを JSON で `console.error` する。
- 管理画面の `deliveryProfiles` 取得失敗時は `[location-stock]` プレフィックスでワーニングを出力。

---

## 5. スコープ・API

- **read_shipping**: 配送プロファイル（`deliveryProfiles`）と `Location.localPickupSettingsV2` の取得に使用。未付与だと配送対応・ローカルデリバリー対応は取得されない。本アプリでは `read_shipping` をスコープに含めている。
- 店舗受け取り対応は `Location.localPickupSettingsV2` の有無で判定。
- **配送対応・ローカルデリバリー対応の判定**: `deliveryProfiles` の `profileLocationGroups` → `locationGroup.locations` と `locationGroupZones`（`zone.name` および `methodDefinitions` の名前）からロケーション単位でフラグを構築。ローカルデリバリーは API に methodType がないため、**ゾーン名・配送方法名**で判定（`isLocalDeliveryMethodName`）。キーワード例: `local` / `ローカル` / `local delivery` / `当日` / `近距離` / `半径` / `地域配達` など。ロケーションが配送プロファイルのロケーショングループに割り当てられていないと表示されないため、ホームの案内カードから「配送設定を開く」で Shopify の設定へ誘導している。

---

## 6. デバッグ・運用

- **配送プロファイルのデバッグ**: ロケーション設定ページを `?debug=delivery` 付きで開くと、サーバーログに `[location-stock] deliveryProfiles:`（プロファイル数・グループ数）、各グループのゾーン名・ロケーション ID、`deliveryFlags map` が出力される。ローカルデリバリーが表示されない場合は、該当ロケーションがプロファイルに含まれているか・ゾーン名がキーワードに合っているかを確認する。
- **API の edges/nodes**: `locationGroupZones`・`methodDefinitions`・`locationGroup.locations` は、接続型で `nodes` のない場合は `edges` から取り出すフォールバックを実装済み。

---

## 7. 参照ドキュメント

- 並び順の詳細: `docs/SORT_ORDER_REQUIREMENTS.md`
- 管理画面 UI ルール: ワークスペース直下 `docs/ADMIN_UI_DESIGN_RULES.md`
- デプロイ確認・スコープ・ローカルデリバリーのトラブルシュート: `docs/DEPLOY_AND_SCOPES.md`
- 店舗受け取りボタンの挙動と Shopify の流れ: `docs/STORE_PICKUP_BUTTON.md`
- 公開用・自社用の toml と Render の対応・それぞれにデプロイする手順: `docs/APP_AND_RENDER_CONFIG.md`
- コミット後のプッシュ・デプロイの流れ: `docs/DEPLOY_STEPS.md`

---

## 8. バックエンド安定化（実装済み）

- **目的**: App Proxy の `missing_admin_client` 等のエラーを減らし、発生時にも原因を特定しやすくする。
- **対応内容**（実装済み）:
  - **環境変数の整備**: デプロイ先（例: Render）で必要な環境変数（`SHOPIFY_API_KEY`, `SHOPIFY_API_SECRET`, `SCOPES` など）の確認手順を `docs/DEPLOY_AND_SCOPES.md` の「6. バックエンドの環境変数」に記載。公開用・自社用で別 Render を使う場合の注意も `docs/APP_AND_RENDER_CONFIG.md` に記載。
  - **エラーログの整理**: App Proxy で `logAppProxyError(shop, variantId, code, message, err)` を呼び出し JSON で `console.error`。管理画面では `[location-stock]` プレフィックスでショップ・ルート・操作内容をログに含める。

---

## 9. config.future の拡張（実装済み）

- **目的**: メタフィールドの `config.future` に定義済みのフラグを、スニペット側で解釈し、表示や動線に反映する。
- **保存**: `buildGlobalConfig` で `config.future` を返す。管理画面の**ロケーション設定**で、エリア設定・近隣店舗表示設定・店舗受取設定からメタフィールドの `config.future` を更新する。
- **実装済みのフラグと挙動**:

| フラグ | 意味 | スニペット側の挙動（実装済み） |
|--------|------|-----------------------------------|
| `groupByRegion` | ロケーションをエリア単位でグルーピングする | `config.regionGroups` と各 stock の `regionKey`（ロケーションの住所または管理画面で割り当てたエリア）でグルーピング。エリア未設定は `regionUnsetLabel`（デフォルト「その他」）で表示。 |
| `regionAccordionEnabled` | エリアごとに折りたたみ表示にする | `groupByRegion` が有効なとき、各地域をアコーディオンで表示。 |
| `regionUnsetLabel` | エリア未設定のロケーションをまとめる見出し文言 | デフォルト「その他」。管理画面のエリア設定で変更可能。 |
| `nearbyFirstEnabled` | 近隣店舗を優先表示する | 一覧最上部に「近隣店舗」アコーディオンを表示。クリックで位置情報取得し、一番近い店舗を表示。`excludeFromNearby` が true のロケーションは近隣検索から除外。 |
| `nearbyOtherCollapsible` | 近隣以外の店舗を折りたたみで表示する | 対応済み（「その他の店舗」で折りたたみ）。 |
| `nearbyOtherHeading` | 近隣店舗の下の「その他」ロケーション一覧の見出し | 近隣店舗を表示にしたとき、その下に並ぶその他ロケーションの直前に表示する見出し。**入力があった場合のみ**見出しを表示し、未入力の場合は見出し行は表示せずロケーション一覧のみ。エリア未設定時に便利。 |
| `showOrderPickButton` | 「この店舗で受け取る」ボタンを表示する | 行ごとに店舗受け取り用ボタンを表示。 |
| `orderPickButtonLabel` | 上記ボタンのラベル文言 | ボタンに表示するテキスト。管理画面の店舗受取設定で変更可能。 |
| `orderPickRedirectToCheckout` | ボタンタップ後にチェックアウトへリダイレクトする | true のとき、カートに追加したあと `/checkout` へリダイレクト。false のときはカートに追加のみ。 |

- **近隣除外**: `config.locations[].excludeFromNearby` を管理画面のロケーション一覧「近隣除外」列で設定。App Proxy の `applyConfigToStocks` で各 stock に `excludeFromNearby` を付与。スニペットの近隣店舗表示では除外してソート・表示。
- **エリア見出し・ボタンのデザイン**: 管理画面には項目なし。テーマ拡張のブロックスキーマ（カスタマイザー）で、エリア見出しの背景色・文字色・文字サイズ・太さ・余白、ボタンの背景色・文字色・角丸・余白・文字サイズを設定可能。スニペットはテーマの設定を優先してスタイルを適用。
- **店舗受け取りボタンのデフォルト動作**: ボタンタップで `location-stock-order-pick` イベント発火のあと、スニペット内で現在バリアントを 1 個カートに追加。`orderPickRedirectToCheckout` が true ならチェックアウトへリダイレクト。詳細は `docs/STORE_PICKUP_BUTTON.md`。

---

## 10. テーマ側の UX 微調整（実装済み）

- **目的**: 商品ページ上の在庫表示ブロックの見やすさ・使いやすさを上げる。
- **対応内容**（実装済み）:
  - **スマホ時の表示**: スニペットの CSS でメディアクエリ（`@media (max-width: 767px)`）を用い、モバイル向けの行間・パディング・フォントサイズを定義済み。
  - **注意書きの可読性**: `.location-stock-indicator__notice` に `white-space: pre-line`、`max-height: 8em`、`overflow-y: auto` を指定済み。
  - **在庫ゼロ時のメッセージ**: 管理画面の**在庫表示設定** → **メッセージ文言**の「在庫なしメッセージ」（`messages.empty`）で設定。商品ページで在庫 0 件のときにその文言を表示。
  - **エリア見出し・ボタンのデザイン**: テーマのカスタマイザー（ブロック「Location stock indicator」のスキーマ）で、エリア見出しの背景色・文字色・文字サイズ・太さ・余白、店舗受け取りボタンの背景色・文字色・角丸・余白・文字サイズを変更可能。

---

## 11. データ分析機能（検討中）

- **目的**: 商品ページ上の在庫表示ブロックの利用状況を把握し、改善や運用に活かす。

- **収集したい指標**:

| 指標 | 説明 | 集計単位 |
|------|------|----------|
| **エリア表示数** | このアプリの在庫ブロックが表示された回数（日別） | 日別 |
| **近隣店舗クリック数** | 近隣店舗をクリックした回数（日別） | 日別 |
| **近隣店舗表示ロケーション数** | そのクリック時に表示されたロケーション数（日別） | 日別 |
| **店舗受け取りボタンのクリック数** | 「この店舗で受け取る」のクリック回数（日別） | 日別 |
| **店舗受け取りボタンのクリックロケーション数** | どのロケーションでクリックされたか（日別・ロケーション別） | 日別・ロケーション別 |

- **表示方針**:
  - 上記を**日別**で蓄積し、管理画面に一覧またはグラフで表示する。
  - 対象期間（例：直近7日・30日）の絞り込み、必要に応じて商品（バリアント）単位のフィルタも検討可能。

- **管理画面の表イメージ（合計＋日別）**  
  - **行**: 1行目を**合計**（選択期間内の全数値の合計）、2行目以降を**日付**（日別の数値）。  
  - **列**: 日付｜エリア表示回数｜近隣店舗クリック数｜（ロケーションごと）〇〇店舗表示｜店舗受け取りボタンクリック数｜（ロケーションごと）〇〇店舗クリック。  
  - ロケーション名（A店舗・B店舗など）は、ショップのロケーション一覧の表示名・公開名に合わせて動的に列を出す想定。

  **例（2/15 〜 2/17 の場合）**:

  | 日付 | エリア表示回数 | 近隣店舗クリック数 | A店舗表示 | B店舗表示 | C店舗表示 | 店舗受け取りボタンクリック数 | A店舗クリック | B店舗クリック | C店舗クリック |
  |------|----------------|---------------------|-----------|-----------|-----------|------------------------------|---------------|---------------|---------------|
  | 合計 | 100 | 10 | 5 | 3 | 2 | 10 | 5 | 3 | 2 |
  | 2/15 | 20 | 3 | 0 | 1 | 2 | 5 | 0 | 3 | 2 |
  | 2/16 | 40 | 3 | 1 | 2 | 0 | 3 | 3 | 0 | 0 |
  | 2/17 | 40 | 4 | 4 | 0 | 0 | 2 | 2 | 0 | 0 |

  - 実装時: 期間内の日別データを取得 → 合計行は各列を合算、日付行はその日の値だけを並べる。**可能**。

---

### 11.1 保存先をメタフィールドにした場合のリスクと対策

保存先に**ショップのメタフィールド**（例: `location_stock.analytics_daily` など）を使う場合のリスクと、取りうる対策をまとめる。

| リスク | 内容 | 対策の例 |
|--------|------|----------|
| **容量制限** | メタフィールドの値にはサイズ上限（JSON で数十KB〜など）がある。日別データを1本の JSON に積み重ねると、数ヶ月〜1年で肥大化する。 | 保持する日数を決めて古い日付を捨てる（例：直近90日分のみ）。または「1メタフィールド＝1日」のように日付ごとにキーを分け、古いキーを定期的に削除する。 |
| **書き込み頻度・API制限** | ストアフロントから「1回表示＝1回APIでメタ更新」にすると、Admin API のレート制限に当たりやすい。 | ストアフロントでは送信だけ行い、**アプリ側でいったんバッファ**（メモリやキュー）に溜めて、**分単位・時間単位でまとめてメタフィールドを更新**する。または送信は軽いログだけにして、集計はバッチで行う。 |
| **同時更新** | 複数リクエストが同時に同じメタフィールドを読んで書き戻すと、片方の加算が消える（ロストアップデート）。 | 更新は**1プロセス・1ジョブに集約**する（例：キューを消費するワーカーが「読む→加算→書く」を直列で実行）。または日付単位でキーを分け、同じ日付の更新を同じワーカーに振る。 |
| **ストアフロントからは書けない** | テーマ／スニペットからはメタフィールドを直接書き込めない。 | ストアフロントは **App Proxy やアプリの API にイベントを送る**だけにし、**アプリサーバーが Admin API でメタフィールドを更新**する構成にする。 |
| **集計の柔軟性** | 日付範囲・ロケーション別・商品別などで後から集計を変えたい場合、大きな JSON を毎回読んで加工するのは手間。 | 必要な期間だけ保持する前提で設計する。複雑な集計が必要になったら、メタフィールドは「生データのコピー」や「キャッシュ」とし、本番の集計は外部DBに移すことも検討する。 |

**結論**: メタフィールドにすること自体は可能だが、**「イベントごとにメタを更新しない」「保持日数に上限を設ける」「更新は1箇所で直列に行う」**を守ればリスクを抑えられる。トラフィックが多くなったり、長期間・多軸での分析が必要になったら、Supabase 等の外部DBへの移行を想定したデータ構造にしておくとよい。

---

### 11.2 1日1レコード・数量のみの場合の容量と保持可能期間

保存形式を「長期間＋商品ごとではなく、1日ごとに数量のみ」にした場合の目安。

- **想定する1日分のデータ例**（イメージ）:

```json
{
  "2025-02-28": {
    "areaDisplayCount": 100,
    "nearbyClickCount": 10,
    "nearbyDisplayByLocation": { "A": 5, "B": 3, "C": 2 },
    "orderPickClickCount": 10,
    "orderPickByLocation": { "A": 5, "B": 3, "C": 2 }
  }
}
```

- **1日あたりのサイズ概算**（JSON 文字列として）:
  - 日付キー＋共通キー＋数値: 約 150〜200 文字
  - ロケーション別オブジェクト: 1ロケーションあたり約 20〜30 文字（ID を短くする場合）
  - ロケーション 5 店舗で約 400〜500 バイト/日、20 店舗で約 700〜900 バイト/日程度

- **メタフィールドの上限**（Shopify の仕様）:
  - API 2026-04 以降: JSON メタフィールドの**書き込み**は **128KB（約 131,072 バイト）** が上限。
  - それより前の API では 2MB まで許容される場合があるが、新規実装では 128KB を前提にした方が安全。

- **128KB で保持できる日数の目安**:

| ロケーション数 | 1日あたり目安 | 128KB で保持できる日数 |
|----------------|----------------|-------------------------|
| 約 5 店舗      | 約 500 バイト | **約 250 日（8〜9 ヶ月）** |
| 約 20 店舗     | 約 800 バイト | **約 160 日（5〜6 ヶ月）** |
| 約 50 店舗     | 約 1,500 バイト | **約 85 日（約 3 ヶ月）** |

- **結論**:  
  - 「1日ごとに数量のみ」なら、**128KB の上限内でおおよそ 3〜9 ヶ月分**は保持できる想定。  
  - 店舗数が少ない（5 店舗程度）なら **約 8〜9 ヶ月**、多い（50 店舗程度）なら **約 3 ヶ月**が目安。  
  - それ以上残したい場合は「直近 N 日分だけメタに保存し、古い日付を削除する」ローテーションを入れるか、**メタフィールドを分割して保存する**か、外部DBに移行する。

---

### 11.3 メタフィールドを分割して保存する場合

1本のメタフィールドではなく、**複数のメタフィールドに分けて保存する**方法なら、容量制限を気にせず長期間保持できる。

- **やり方の例（月単位で分割）**
  - キーを「月」ごとに分ける。例: `location_stock.analytics_2025_02`（2025年2月分）、`location_stock.analytics_2025_03`（3月分）…
  - 各メタフィールドの値は「その月の日付ごとのデータ」だけの JSON（1ヶ月分なので 30 日×500 バイト ≒ 15KB 程度で 128KB に余裕で収まる）。
  - 書き込み時: 対象日付の「月」に対応するキーを決め、そのメタを読んで該当日を更新し、書き戻す。
  - 参照時: 必要な月のキーだけ読む（例: 直近 30 日なら 1〜2 個のメタフィールドだけ読めばよい）。

- **難易度**
  - **難しくない**。日付から「キー（例: `analytics_YYYY_MM`）」を決めるロジックと、「該当メタを読む → 日付キーで更新 → 書く」を追加するだけ。既存の「1本の JSON で全期間」の実装を「キーを動的にする」ように変える程度。

- **注意点**
  - ショップあたりのメタフィールド「定義」数には上限（例: アプリあたり 256 など）があるが、月単位なら 1 年で 12 キーなので、数年〜十数年分を保持しても問題になりにくい。
  - 古い月を捨てる場合は、その月のキーのメタフィールドを削除する（または更新しない）運用にすればよい。

**まとめ**: 分割保存にすれば、**1メタ＝1ヶ月**などにしておくことで各メタは 128KB 以内に収まり、かつ長期間のデータをメタフィールドだけで持てる。実装コストもそれほど高くない。

- **月を跨いだ日別の期間表示**
  - 例: 「2/15 〜 3/15」のように月をまたぐ期間を指定したときは、**その期間に含まれる月のメタフィールドを複数読む**だけになる。
  - 手順: ① 表示したい開始日・終了日から「どの月が含まれるか」を計算（2/15〜3/15 → 2025_02 と 2025_03）。② それらのキー（例: `analytics_2025_02`, `analytics_2025_03`）のメタを取得（1回の GraphQL で複数キーを指定して取れる）。③ 各メタの JSON を「日付をキーにしたオブジェクト」としてマージ。④ 開始日〜終了日の範囲でフィルタして日付順に並べ、表示。
  - 月を跨いでも**難しくならない**。読むメタが 2〜3 個になるだけなので、API の読み取り回数・処理量とも増え方は小さい。

---

- **実装に必要な検討事項**（再掲・補足）:
  1. **保存先**: メタフィールドとする場合は上記リスク・対策を前提に設計。外部DB（Supabase 等）なら容量・同時更新・集計の柔軟性は取りやすいが、運用・コストは別途検討。
  2. **送信経路**: 商品ページ（スニペット）→ App Proxy またはアプリ API に POST。送信内容は「イベント種別・日付・オプション（ロケーションIDなど）」程度の軽いペイロードにし、集計はサーバー側で行う。
  3. **管理画面**: 新規ルート（例: `app.analytics.jsx`）で一覧・グラフを表示。日付範囲選択、指標の並びや凡例を用意。
  4. **プライバシー・負荷**: 個人を特定しない集計に留める。同一セッションの連打は1回にまとめるなど、送信頻度を抑える。

- **次のステップ**: 保存先（メタフィールド or 外部DB）と送信経路を決め、データ構造（例: `{ date, areaDisplayCount, nearbyClickCount, nearbyLocationCount, orderPickClickCount, orderPickByLocation }`）と API 仕様を定義してから、スニペットの送信処理と管理画面の表示を実装する。
